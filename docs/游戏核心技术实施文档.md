# 2D 太空射击游戏核心技术实施文档 (ECS + TypeScript)

## 一、核心架构原则

1.  **纯粹 ECS 模式**：
    *   **Entity**：仅仅是一个数字 ID (`number`)。
    *   **Component**：纯数据容器（Class），**严禁包含业务逻辑**。
    *   **System**：纯逻辑函数，每帧遍历组件，**严禁持有状态**。
2.  **数据与逻辑分离**：
    *   **Blueprint (蓝图)**：实体**出生瞬间**的快照（JSON），负责 `new` 组件。
    *   **Spec (配置/规格)**：系统**运行时查表**的字典（常量），负责数值平衡。
    *   **Gallery (图鉴)**：UI **展示用**数据（文本/图标），与核心逻辑解耦。
3.  **确定性与生命周期**：
    *   事件队列 (`world.events`) 本帧生产，帧末清空。
    *   实体销毁通过 `DestroyTag` 标记，帧末统一清理 (`CleanupSystem`)。
    *   渲染与逻辑分离：React 负责 UI (HUD)，Canvas/WebGL 负责游戏画面。

---

## 二、目录结构规范

```text
src/
├─ engine/
│   ├─ components/          # 所有组件类定义 (纯数据)
│   │   ├─ index.ts         # 统一导出
│   │   └─ ...
│   ├─ blueprints/          # [实体工厂数据] 决定实体"长什么样"
│   │   ├─ types.ts         # 自动推导的 Blueprint 类型
│   │   ├─ enemies.ts       # 敌人出生配置
│   │   └─ pickups.ts       # 掉落物出生配置
│   ├─ configs/             # [静态数值表] 决定系统"怎么运行"
│   │   ├─ weapons.ts       # 武器表 (CD, AmmoID)
│   │   ├─ ammo.ts          # 弹药表 (Speed, Damage, Shape)
│   │   ├─ effects.ts       # 效果表 (Explosion radius)
│   │   ├─ growth.ts        # 玩家成长数值表
│   │   └─ gallery.ts       # UI展示数据 (Name, Desc, Icon)
│   ├─ factory/             # [核心引擎] JSON -> Component 映射
│   │   └─ index.ts         # ArgMap 映射表 & spawn 函数
│   ├─ systems/             # [逻辑核心] 每帧执行的系统
│   │   ├─ ...
│   │   └─ loop.ts          # 系统执行顺序编排
│   ├─ world.ts             # World 状态定义 & 事件池
│   └─ events.ts            # 事件类型定义
├─ ui/                      # React UI 层
└─ main.ts                  # 入口
```

---

## 三、核心数据结构

### 1. World (全局状态)

修正点：`playerLevel` 不作为组件，而是作为 World 的全局字段，避免被 CleanupSystem 误删，也方便全局读取。

```typescript
export interface World {
  entities: Map<number, Component[]>; // 实体数据库
  nextId: number;                     // ID 自增计数器
  playerId: number;                   // 缓存玩家 ID
  
  // 全局状态
  state: 'MENU' | 'PLAYING' | 'PAUSED' | 'GAMEOVER';
  score: number;
  playerLevel: number;                // 玩家当前等级
  playerExp: number;
  
  // 事件系统
  events: GameEvent[];                // 本帧事件池 (帧末清空)
}
```

### 2. Component (组件)

组件必须是类，便于 `instanceof` 检查，但构造函数应保持简单。

```typescript
// components/index.ts
export abstract class Component {}

export class Transform extends Component {
  constructor(public x: number, public y: number, public rot: number = 0) { super(); }
}
export class Weapon extends Component {
  constructor(
    public id: string,           // 引用 configs/weapons.ts
    public cooldown: number,     // 当前总冷却 (受成长影响)
    public timer: number = 0,    // 冷却倒计时
    public slot: 'main' | 'sub', // 插槽位
    public level: number = 1     // 武器等级
  ) { super(); }
}
// ... 其他组件：Health, Velocity, Collider, Sprite, Lifetime, Buff ...
```

### 3. Blueprint (蓝图类型)

利用 TypeScript 映射类型，实现**组件变更后自动更新蓝图类型定义**。

```typescript
// blueprints/types.ts
import * as C from '@/engine/components';

// 移除 abstract class Component，获取所有具体组件类
type ComponentMap = typeof C;

export type Blueprint = {
  [K in keyof ComponentMap]?: ConstructorParameters<ComponentMap[K]>;
};
```

---

## 四、配置体系 (Blueprint vs Config)

**核心原则**：
*   **Blueprint**：描述**实例**（例如：地上的一个道具包）。
*   **Config**：描述**规则**（例如：激光枪的射速）。

### 1. 静态配置 (Configs)

```typescript
// configs/weapons.ts
export const WEAPON_SPECS: Record<string, WeaponSpec> = {
  'plasma_gun': {
    baseCooldown: 200,
    ammoType: 'plasma_blue',
    maxLevel: 10
  }
};

// configs/ammo.ts
export const AMMO_SPECS: Record<string, AmmoSpec> = {
  'plasma_blue': {
    speed: 800,
    damage: 50,
    hitboxRadius: 8,
    onHitEffects: ['small_explosion'] // 引用 effects 表
  }
};
```

### 2. 实体蓝图 (Blueprints)

```typescript
// blueprints/pickups.ts
import type { Blueprint } from './types';

export const DROP_PLASMA_GUN: Blueprint = {
  // 工厂根据 key 自动 new Transform(...args)
  Transform: [0, 0, 0], // 坐标通常由 spawn 函数动态覆盖
  Sprite:    ['pickup_icon', 0, 0, 32, 32],
  Collider:  ['circle', 16],
  // PickupItem 组件：类型为 weapon，ID 为 plasma_gun
  PickupItem: ['weapon', 'plasma_gun'], 
  Lifetime:  [30] // 30秒后消失
};
```

---

## 五、工厂系统 (Factory)

这是连接 JSON 蓝图与 Class 组件的唯一桥梁。**新增组件时，只需在此文件加一行映射。**

```typescript
// factory/index.ts
import * as C from '@/engine/components';
import { Blueprint } from '@/engine/blueprints/types';

// 参数映射表：将数组参数映射到构造函数
const ArgMap: Record<keyof typeof C, (args: any[]) => any[]> = {
  Transform: (a) => a, 
  Weapon:    (a) => a,
  Health:    (a) => a,
  Sprite:    (a) => a,
  // ... 新增组件在此添加
};

export function spawnEntity(world: World, blueprint: Blueprint, overrides?: Partial<Blueprint>) {
  const id = world.nextId++;
  const components: Component[] = [];
  
  // 合并 overrides (例如出生坐标)
  const finalConfig = { ...blueprint, ...overrides };

  for (const [key, args] of Object.entries(finalConfig)) {
    const ComponentClass = (C as any)[key];
    const mapFn = (ArgMap as any)[key];
    
    if (ComponentClass && mapFn) {
      // 实例化组件
      components.push(new ComponentClass(...mapFn(args)));
    }
  }
  
  world.entities.set(id, components);
  return id;
}
```

---

## 六、关键系统逻辑实现

### 1. 武器与弹药流程

**流程**：`Input` -> `WeaponSystem` (查表) -> `spawnBullet` -> `CollisionSystem` -> `EffectSystem`

```typescript
// systems/WeaponSystem.ts
export function WeaponSystem(world: World, dt: number) {
  // 1. 遍历持有武器的实体
  for (const [id, [weapon, trans, intent]] of query(world, [Weapon, Transform, FireIntent])) {
    // 冷却逻辑
    if (weapon.timer > 0) {
      weapon.timer -= dt;
      continue;
    }

    // 开火逻辑
    if (intent.firing) {
      const spec = WEAPON_SPECS[weapon.id]; // 1. 查 Weapon 表
      const ammoSpec = AMMO_SPECS[spec.ammoType]; // 2. 查 Ammo 表
      
      // 3. 生成子弹实体
      spawnBullet(world, {
        x: trans.x, 
        y: trans.y, 
        rot: trans.rot,
        speed: ammoSpec.speed,
        damage: ammoSpec.damage * (1 + 0.1 * weapon.level), // 简单的等级伤害公式
        radius: ammoSpec.hitboxRadius,
        effects: ammoSpec.onHitEffects
      });

      // 重置冷却 (应用玩家全局属性加成)
      weapon.timer = spec.baseCooldown; 
    }
  }
}
```

### 2. 道具拾取与 Buff 系统

**修正**：Buff 统一作为 `BuffComponent` 挂载在玩家实体上。

```typescript
// systems/PickupSystem.ts
export function PickupSystem(world: World) {
  const player = world.entities.get(world.playerId);
  if (!player) return;

  // 检测碰撞事件 (由 CollisionSystem 产生)
  for (const event of world.events) {
    if (event.type === 'COLLISION' && event.targetId === world.playerId) {
      const otherComp = world.entities.get(event.sourceId);
      const pickup = otherComp?.find(c => c instanceof PickupItem);
      
      if (pickup) {
        handlePickup(world, player, pickup);
        // 销毁道具实体
        world.entities.get(event.sourceId)!.push(new DestroyTag());
      }
    }
  }
}

function handlePickup(world: World, player: Component[], pickup: PickupItem) {
  if (pickup.type === 'weapon') {
    // 逻辑：已有同名武器则升级，否则换装/装备
    // 修改 player 身上的 Weapon 组件
  } else if (pickup.type === 'buff') {
    // 查表获取 Buff 详情
    const buffSpec = EFFECT_SPECS[pickup.id]; 
    // 直接给玩家挂一个 Buff 组件
    player.push(new BuffComponent(pickup.id, buffSpec.duration, buffSpec.value));
  }
}
```

### 3. 协同系统 (Synergy)

基于事件驱动，解耦武器逻辑与特效逻辑。

*   **触发**：`WeaponSystem` 发射时或 `CollisionSystem` 命中时，若检测到副武器，抛出 `SYNERGY_EVENT`。
*   **响应**：`SynergySystem` 监听该事件。

```typescript
// systems/SynergySystem.ts
export function SynergySystem(world: World) {
  for (const ev of world.events) {
    if (ev.type === 'SYNERGY_TRIGGER') {
      const comboKey = `${ev.mainWeaponId}+${ev.subWeaponId}`;
      const synergy = SYNERGY_TABLE[comboKey];
      
      if (synergy) {
        // 执行协同效果：如发射特殊子弹、全屏AOE等
        executeSynergy(world, synergy, ev.position);
      }
    }
  }
}
```

---

## 七、系统执行顺序 (Loop)

顺序至关重要，决定了游戏的帧逻辑正确性。

```typescript
// systems/index.ts
const systems = [
  InputSystem,         // 1. 收集输入 -> 生成 MoveIntent/FireIntent
  AISteerSystem,       // 2. AI 思考 -> 生成 MoveIntent/FireIntent
  
  BuffSystem,          // 3. 更新 Buff 计时，修改实体属性 (Speed/Damage)
  LevelUpSystem,       // 4. 检查经验值 -> 修改全局属性/实体组件
  
  WeaponSystem,        // 5. 读 Intent -> 读 Config -> 生成子弹
  MovementSystem,      // 6. 读 Intent + Speed -> 改 Transform
  
  CollisionSystem,     // 7. 物理碰撞 -> 产生 CollisionEvent / 扣血
  SynergySystem,       // 8. 读 Event -> 产生额外效果
  
  DamageSystem,        // 9. 结算最终死亡 -> 挂 DestroyTag -> 产生掉落
  PickupSystem,        // 10. 玩家拾取处理
  
  EffectSystem,        // 11. 视觉特效更新 (粒子/震屏)
  CleanupSystem,       // 12. 删除 DestroyTag 实体，清空 Event 队列
  
  RenderSystem         // 13. (Canvas) 绘制所有 Sprite
];
```

---

## 八、开发与扩展 SOP (标准作业程序)

### 场景 1：新增一把“散弹枪”
1.  **configs/weapons.ts**: 添加 `shotgun: { cooldown: 800, ammoType: 'pellet' }`。
2.  **configs/ammo.ts**: 添加 `pellet: { speed: 600, onHit: ['knockback'] }`。
3.  **configs/gallery.ts**: 添加 UI 描述（名字、图标）。
4.  *(可选)* **blueprints/pickups.ts**: 添加 `DROP_SHOTGUN` 蓝图用于掉落。
5.  **无需修改代码逻辑**。

### 场景 2：新增一种“护盾” Buff
1.  **configs/effects.ts**: 添加 `shield_buff: { type: 'shield', duration: 10, value: 50 }`。
2.  **systems/BuffSystem.ts**: 在 `switch(buff.type)` 中添加 `case 'shield'` 的逻辑（例如每帧增加临时 HP 或无敌）。
3.  **blueprints/pickups.ts**: 添加 `DROP_SHIELD_BUFF` 蓝图。

### 场景 3：新增一个组件（例如 `Stealth` 隐身）
1.  **components/index.ts**: 定义 `class Stealth extends Component { ... }`。
2.  **factory/index.ts**: 在 `ArgMap` 中添加 `Stealth: (args) => args`。
3.  **blueprints/**: 现在任何蓝图都可以使用 `Stealth: { duration: 5 }` 字段了（TypeScript 自动提示）。
4.  **systems/**: 编写 `StealthSystem` 或在 `RenderSystem` 中处理透明度。

---

## 九、总结

本架构方案的核心优势在于：
1.  **类型安全**：TypeScript 自动推导蓝图类型，防止配置拼写错误。
2.  **数据驱动**：90% 的游戏内容调整（数值、掉落、组合）仅需修改 `configs` 和 `blueprints`，无需触碰逻辑代码。
3.  **逻辑清晰**：System 职责单一，Event 解耦复杂交互，Cleanup 统一管理内存。
4.  **可维护性**：工厂模式一次性写死，后续扩展零成本。